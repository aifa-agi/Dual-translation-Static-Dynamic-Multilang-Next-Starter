
```ts
// @/app/[lang]/@left/(_ARTIFACT)/(_subfractals)/(_RESPONSE_PARSER)/(_shared)/(_types)/fractal-response-parser-types.ts [file:1]


export type AllFractalResponseParserTranslationKeys =
  | "serverTitle"
  | "serverDescription"
  | "serverHint"
  | "specMode"
  | "codeMode"
  | "specModeDescription"
  | "codeModeDescription"
  | "markdownInputPlaceholder"
  | "parseCodeButtonLabel"
  | "parseCodeButtonHint"
  | "parseCodeStatusIdle"
  | "parseCodeStatusRunning"
  | "parseCodeStatusSuccess"
  | "parseCodeStatusError"
  | "parseCodeStatusNoBlocks"
  | "loadLatestFileButtonLabel"
  | "loadLatestFileButtonHint"
  | "loadFileStatusIdle"
  | "loadFileStatusLoading"
  | "loadFileStatusSuccess"
  | "loadFileStatusError"
  | "clientTitle"
  | "clientDescription"
  | "clientHint"
  | "usageStepSetupExport"
  | "usageStepExportMarkdown"
  | "usageStepReviewAndSave"
  | "applyButtonLabel"
  | "applyButtonLabelApplying"
  | "clearAllButtonLabel"
  | "loadLatestResponseTitle";

export type FractalResponseParserTranslations = {
  [K in AllFractalResponseParserTranslationKeys]: string;
};

export type FractalResponseParserPageData = {
  fractalName?: string;
  fractalPath?: string;
  fractalLevel?: number;
  fractalDescription?: string;
  hint?: string;
};

export type FractalResponseParserCodeBlock = {
  id: string;
  language: string | null;
  code: string;
  pathComment?: string;
  inferredFilePath?: string;
  isSpecBlock: boolean;
  startLine: number;
  endLine: number;
};

export type FractalResponseParserParseIssue = {
  codeBlockId?: string;
  message: string;
  severity: "info" | "warning" | "error";
};

export type FractalResponseParserParseResult = {
  originalMarkdownLength: number;
  codeBlocks: FractalResponseParserCodeBlock[];
  issues: FractalResponseParserParseIssue[];
};

export type FractalResponseParserPlannedFileOperationKind =
  | "create"
  | "write"
  | "update"
  | "skip";

export type FractalResponseParserPlannedFileChange = {
  targetPath: string;
  language: string;
  code: string;
  operation: FractalResponseParserPlannedFileOperationKind;
  reason?: string;
  sourceCodeBlockId: string;
};

export type FractalResponseParserApplyFileStatus =
  | "pending"
  | "applied"
  | "failed"
  | "skipped";

export type FractalResponseParserAppliedFileResult = {
  targetPath: string;
  status: FractalResponseParserApplyFileStatus;
  message?: string;
};

export type FractalResponseParserApplyResult = {
  plannedChanges: FractalResponseParserPlannedFileChange[];
  appliedResults: FractalResponseParserAppliedFileResult[];
  hasErrors: boolean;
};

/**
 * NEW TYPES FOR 2-PHASE WORKFLOW: Parse ‚Üí Apply
 *
 * Parsed file ready for preview and editing after Extract phase,
 * before Apply phase.
 */
export type FractalResponseParserParsedFile = {
  /** unique ID for React keys */
  id: string;
  /** editable path where file will be written */
  targetPath: string;
  /** editable file content */
  content: string;
  /** file extension / language (tsx, ts, json, md, css, etc.) */
  language: string;
  /** number of lines in content */
  linesCount: number;
  /** original path extracted from comment for reference */
  originalPath?: string;
  /** flag indicating if user modified path or content */
  isEdited: boolean;
};

/**
 * Result of Extract phase: parsing markdown and extracting files.
 */
export type FractalResponseParserExtractResult = {
  /** successfully extracted files */
  files: FractalResponseParserParsedFile[];
  /** total code blocks found in markdown */
  totalBlocks: number;
  /** blocks without valid path */
  skippedBlocks: number;
  /** parse errors */
  errors: string[];
};

/**
 * Input for Apply phase: write files to filesystem.
 */
export type FractalResponseParserApplyRequest = {
  /** files to write, potentially edited by user */
  files: FractalResponseParserParsedFile[];
};

/**
 * Result of applying a single file to filesystem.
 */
export type FractalResponseParserApplyFileResult = {
  /** path where file was written */
  targetPath: string;
  /** result status */
  status: "applied" | "failed" | "skipped";
  /** error message or additional info */
  message?: string;
};

/**
 * Complete result of Apply phase.
 */
export type FractalResponseParserApplyPhaseResult = {
  /** result for each file */
  results: FractalResponseParserApplyFileResult[];
  /** number of successfully written files */
  successCount: number;
  /** number of failed writes */
  failedCount: number;
  /** number of skipped files */
  skippedCount: number;
};

/**
 * Parse status for UI.
 */
export type FractalResponseParserParseStatus =
  | "idle"
  | "parsing"
  | "success"
  | "error"
  | "no-blocks";

/**
 * Apply status for UI.
 */
export type FractalResponseParserApplyStatus =
  | "idle"
  | "applying"
  | "success"
  | "error";

/**
 * NEW TYPES FOR v0.3.0: File Reading from public/
 *
 * Result of reading latest file from public/response-for-parsing.
 */
export type FractalResponseParserReadFileResult = {
  /** whether file was successfully read */
  success: boolean;
  /** file content */
  content?: string;
  /** name of the file */
  fileName?: string;
  /** size in bytes */
  fileSize?: number;
  /** ISO date string of last modification */
  modifiedAt?: string;
  /** error message if failed */
  error?: string;
};

/**
 * Load file status for UI.
 */
export type FractalResponseParserLoadFileStatus =
  | "idle"
  | "loading"
  | "success"
  | "error";
```

```json
// app/[lang]/@left/(_ARTIFACT)/(_subfractals)/(_RESPONSE_PARSER)/(_shared)/(_translations)/fractal-response-parser-translation.json [file:1]
{
  "cm3responseparser001": {
    "key": "serverTitle",
    "translations": {
      "en": "Response Parser",
      "ru": "–ü–∞—Ä—Å–µ—Ä –æ—Ç–≤–µ—Ç–æ–≤",
      "es": "Analizador de respuestas"
    }
  },
  "cm3responseparser002": {
    "key": "serverDescription",
    "translations": {
      "en": "Parse Perplexity Markdown answers and extract code blocks for the current fractal.",
      "ru": "–†–∞–∑–±–∏—Ä–∞–µ—Ç Markdown-–æ—Ç–≤–µ—Ç—ã Perplexity –∏ –∏–∑–≤–ª–µ–∫–∞–µ—Ç –±–ª–æ–∫–∏ –∫–æ–¥–∞ –¥–ª—è —Ç–µ–∫—É—â–µ–≥–æ —Ñ—Ä–∞–∫—Ç–∞–ª–∞.",
      "es": "Analiza respuestas Markdown de Perplexity y extrae bloques de c√≥digo para el fractal actual."
    }
  },
  "cm3responseparser003": {
    "key": "serverHint",
    "translations": {
      "en": "Paste the full Markdown response from Perplexity and run the parser in CODE mode.",
      "ru": "–í—Å—Ç–∞–≤—å—Ç–µ –ø–æ–ª–Ω—ã–π Markdown-–æ—Ç–≤–µ—Ç –æ—Ç Perplexity –∏ –∑–∞–ø—É—Å—Ç–∏—Ç–µ –ø–∞—Ä—Å–µ—Ä –≤ —Ä–µ–∂–∏–º–µ CODE.",
      "es": "Pega la respuesta completa en Markdown desde Perplexity y ejecuta el analizador en modo CODE."
    }
  },
  "cm3responseparser004": {
    "key": "specMode",
    "translations": {
      "en": "SPEC mode",
      "ru": "–†–µ–∂–∏–º SPEC",
      "es": "Modo SPEC"
    }
  },
  "cm3responseparser005": {
    "key": "codeMode",
    "translations": {
      "en": "CODE mode",
      "ru": "–†–µ–∂–∏–º CODE",
      "es": "Modo CODE"
    }
  },
  "cm3responseparser006": {
    "key": "specModeDescription",
    "translations": {
      "en": "Focus on SPEC and documentation changes without touching code files.",
      "ru": "–°—Ñ–æ–∫—É—Å–∏—Ä–æ–≤–∞–Ω –Ω–∞ –∏–∑–º–µ–Ω–µ–Ω–∏—è—Ö SPEC –∏ –¥–æ–∫—É–º–µ–Ω—Ç–∞—Ü–∏–∏ –±–µ–∑ –∏–∑–º–µ–Ω–µ–Ω–∏—è —Ñ–∞–π–ª–æ–≤ –∫–æ–¥–∞.",
      "es": "Se centra en cambios de SPEC y documentaci√≥n sin tocar archivos de c√≥digo."
    }
  },
  "cm3responseparser007": {
    "key": "codeModeDescription",
    "translations": {
      "en": "Focus on code blocks and planned file operations derived from Perplexity output.",
      "ru": "–°—Ñ–æ–∫—É—Å–∏—Ä–æ–≤–∞–Ω –Ω–∞ –±–ª–æ–∫–∞—Ö –∫–æ–¥–∞ –∏ –ø–ª–∞–Ω–∏—Ä—É–µ–º—ã—Ö —Ñ–∞–π–ª–æ–≤—ã—Ö –æ–ø–µ—Ä–∞—Ü–∏—è—Ö –∏–∑ –æ—Ç–≤–µ—Ç–∞ Perplexity.",
      "es": "Se centra en bloques de c√≥digo y operaciones de archivo planificadas a partir de la respuesta de Perplexity."
    }
  },
  "cm3responseparser008": {
    "key": "markdownInputPlaceholder",
    "translations": {
      "en": "Paste the full Markdown answer from Perplexity here",
      "ru": "–í—Å—Ç–∞–≤—å—Ç–µ —Å—é–¥–∞ –ø–æ–ª–Ω—ã–π Markdown-–æ—Ç–≤–µ—Ç –æ—Ç Perplexity",
      "es": "Pega aqu√≠ la respuesta completa en Markdown desde Perplexity"
    }
  },
  "cm3responseparser009": {
    "key": "parseCodeButtonLabel",
    "translations": {
      "en": "Parse CODE blocks",
      "ru": "–†–∞–∑–æ–±—Ä–∞—Ç—å –±–ª–æ–∫–∏ –∫–æ–¥–∞",
      "es": "Analizar bloques de c√≥digo"
    }
  },
  "cm3responseparser010": {
    "key": "parseCodeButtonHint",
    "translations": {
      "en": "Extract code blocks and infer planned file operations from the Markdown answer.",
      "ru": "–ò–∑–≤–ª–µ–∫–∞–µ—Ç –±–ª–æ–∫–∏ –∫–æ–¥–∞ –∏ —Ñ–æ—Ä–º–∏—Ä—É–µ—Ç –ø–ª–∞–Ω —Ñ–∞–π–ª–æ–≤—ã—Ö –æ–ø–µ—Ä–∞—Ü–∏–π –∏–∑ Markdown-–æ—Ç–≤–µ—Ç–∞.",
      "es": "Extrae bloques de c√≥digo e infiere operaciones de archivo planificadas a partir de la respuesta en Markdown."
    }
  },
  "cm3responseparser011": {
    "key": "parseCodeStatusIdle",
    "translations": {
      "en": "Ready to parse.",
      "ru": "–ì–æ—Ç–æ–≤ –∫ —Ä–∞–∑–±–æ—Ä—É.",
      "es": "Listo para analizar."
    }
  },
  "cm3responseparser012": {
    "key": "parseCodeStatusRunning",
    "translations": {
      "en": "Parsing Markdown and extracting code blocks.",
      "ru": "–†–∞–∑–±–∏—Ä–∞–µ–º Markdown –∏ –∏–∑–≤–ª–µ–∫–∞–µ–º –±–ª–æ–∫–∏ –∫–æ–¥–∞.",
      "es": "Analizando Markdown y extrayendo bloques de c√≥digo."
    }
  },
  "cm3responseparser013": {
    "key": "parseCodeStatusSuccess",
    "translations": {
      "en": "Parsing finished successfully.",
      "ru": "–†–∞–∑–±–æ—Ä —É—Å–ø–µ—à–Ω–æ –∑–∞–≤–µ—Ä—à—ë–Ω.",
      "es": "El an√°lisis se complet√≥ correctamente."
    }
  },
  "cm3responseparser014": {
    "key": "parseCodeStatusError",
    "translations": {
      "en": "Parsing failed. Please check the Markdown structure.",
      "ru": "–†–∞–∑–±–æ—Ä –Ω–µ —É–¥–∞–ª—Å—è. –ü—Ä–æ–≤–µ—Ä—å—Ç–µ —Å—Ç—Ä—É–∫—Ç—É—Ä—É Markdown.",
      "es": "El an√°lisis fall√≥. Comprueba la estructura del Markdown."
    }
  },
  "cm3responseparser015": {
    "key": "parseCodeStatusNoBlocks",
    "translations": {
      "en": "No code blocks were found in the Markdown answer.",
      "ru": "–í Markdown-–æ—Ç–≤–µ—Ç–µ –Ω–µ –Ω–∞–π–¥–µ–Ω–æ –Ω–∏ –æ–¥–Ω–æ–≥–æ –±–ª–æ–∫–∞ –∫–æ–¥–∞.",
      "es": "No se encontraron bloques de c√≥digo en la respuesta en Markdown."
    }
  },
  "cm3responseparser016": {
    "key": "loadLatestFileButtonLabel",
    "translations": {
      "en": "Read last file",
      "ru": "–ü—Ä–æ—á–∏—Ç–∞—Ç—å –ø–æ—Å–ª–µ–¥–Ω–∏–π —Ñ–∞–π–ª",
      "es": "Leer √∫ltimo archivo"
    }
  },
  "cm3responseparser017": {
    "key": "loadLatestFileButtonHint",
    "translations": {
      "en": "Read the latest Markdown file from public/response-for-parsing.",
      "ru": "–ß–∏—Ç–∞–µ—Ç –ø–æ—Å–ª–µ–¥–Ω–∏–π Markdown-—Ñ–∞–π–ª –∏–∑ public/response-for-parsing.",
      "es": "Lee el √∫ltimo archivo Markdown desde public/response-for-parsing."
    }
  },
  "cm3responseparser018": {
    "key": "loadFileStatusIdle",
    "translations": {
      "en": "Ready to load.",
      "ru": "–ì–æ—Ç–æ–≤ –∫ –∑–∞–≥—Ä—É–∑–∫–µ.",
      "es": "Listo para cargar."
    }
  },
  "cm3responseparser019": {
    "key": "loadFileStatusLoading",
    "translations": {
      "en": "Loading file...",
      "ru": "–ó–∞–≥—Ä—É–∂–∞–µ–º —Ñ–∞–π–ª...",
      "es": "Cargando archivo..."
    }
  },
  "cm3responseparser020": {
    "key": "loadFileStatusSuccess",
    "translations": {
      "en": "File loaded successfully.",
      "ru": "–§–∞–π–ª —É—Å–ø–µ—à–Ω–æ –∑–∞–≥—Ä—É–∂–µ–Ω.",
      "es": "Archivo cargado correctamente."
    }
  },
  "cm3responseparser021": {
    "key": "loadFileStatusError",
    "translations": {
      "en": "Failed to load file.",
      "ru": "–ù–µ —É–¥–∞–ª–æ—Å—å –∑–∞–≥—Ä—É–∑–∏—Ç—å —Ñ–∞–π–ª.",
      "es": "No se pudo cargar el archivo."
    }
  },
  "cm3responseparser022": {
    "key": "clientTitle",
    "translations": {
      "en": "PerplexityPro Markdown parser",
      "ru": "–ü–∞—Ä—Å–µ—Ä PerplexityPro Markdown",
      "es": "Analizador de Markdown de PerplexityPro"
    }
  },
  "cm3responseparser023": {
    "key": "clientDescription",
    "translations": {
      "en": "This tab converts Perplexity answers into filesystem components bound to AIFA routes.",
      "ru": "–≠—Ç–∞ –≤–∫–ª–∞–¥–∫–∞ –ø—Ä–µ–≤—Ä–∞—â–∞–µ—Ç –æ—Ç–≤–µ—Ç—ã Perplexity –≤ –∫–æ–º–ø–æ–Ω–µ–Ω—Ç—ã —Ñ–∞–π–ª–æ–≤–æ–π —Å–∏—Å—Ç–µ–º—ã, –ø—Ä–∏–≤—è–∑–∞–Ω–Ω—ã–µ –∫ –º–∞—Ä—à—Ä—É—Ç–∞–º AIFA.",
      "es": "Esta pesta√±a convierte respuestas de Perplexity en componentes del sistema de archivos vinculados a rutas AIFA."
    }
  },
  "cm3responseparser024": {
    "key": "clientHint",
    "translations": {
      "en": "Use it when Perplexity returns only components and you want to materialize them as project files.",
      "ru": "–ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ –µ—ë, –∫–æ–≥–¥–∞ Perplexity –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç —Ç–æ–ª—å–∫–æ –∫–æ–º–ø–æ–Ω–µ–Ω—Ç—ã –∏ –≤—ã —Ö–æ—Ç–∏—Ç–µ –ø—Ä–µ–≤—Ä–∞—Ç–∏—Ç—å –∏—Ö –≤ —Ñ–∞–π–ª—ã –ø—Ä–æ–µ–∫—Ç–∞.",
      "es": "√ösala cuando Perplexity devuelva solo componentes y quieras materializarlos como archivos del proyecto."
    }
  },
  "cm3responseparser025": {
    "key": "usageStepSetupExport",
    "translations": {
      "en": "Configure your browser to save downloaded files into the project folder public/response-for-parsing.",
      "ru": "–í –±—Ä–∞—É–∑–µ—Ä–µ –Ω–∞—Å—Ç—Ä–æ–π—Ç–µ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ —Å–∫–∞—á–∏–≤–∞–µ–º—ã—Ö —Ñ–∞–π–ª–æ–≤ –≤ –ø–∞–ø–∫—É –ø—Ä–æ–µ–∫—Ç–∞ public/response-for-parsing.",
      "es": "Configura tu navegador para guardar los archivos descargados en la carpeta del proyecto public/response-for-parsing."
    }
  },
  "cm3responseparser026": {
    "key": "usageStepExportMarkdown",
    "translations": {
      "en": "When you receive an answer that contains only components, export it as Markdown using the button below the chat.",
      "ru": "–ö–æ–≥–¥–∞ –≤—ã –ø–æ–ª—É—á–∏—Ç–µ –æ—Ç–≤–µ—Ç, –∫–æ—Ç–æ—Ä—ã–π —Å–æ–¥–µ—Ä–∂–∏—Ç —Ç–æ–ª—å–∫–æ –∫–æ–º–ø–æ–Ω–µ–Ω—Ç—ã, —ç–∫—Å–ø–æ—Ä—Ç–∏—Ä—É–π—Ç–µ –µ–≥–æ –≤ Markdown —Å –ø–æ–º–æ—â—å—é –∫–Ω–æ–ø–∫–∏ –ø–æ–¥ —á–∞—Ç–æ–º.",
      "es": "Cuando recibas una respuesta que solo contenga componentes, exp√≥rtala como Markdown usando el bot√≥n debajo del chat."
    }
  },
  "cm3responseparser027": {
    "key": "usageStepReviewAndSave",
    "translations": {
      "en": "Then click ‚ÄúRead last file‚Äù. If the file is valid you will see components. Review them, delete extra ones, edit if needed, and click ‚ÄúSave latest changes to filesystem‚Äù.",
      "ru": "–ó–∞—Ç–µ–º –Ω–∞–∂–º–∏—Ç–µ –∫–Ω–æ–ø–∫—É ¬´–ü—Ä–æ—á–∏—Ç–∞—Ç—å –ø–æ—Å–ª–µ–¥–Ω–∏–π —Ñ–∞–π–ª¬ª. –ï—Å–ª–∏ —Ñ–∞–π–ª –≤–∞–ª–∏–¥–µ–Ω, –≤—ã —É–≤–∏–¥–∏—Ç–µ –∫–æ–º–ø–æ–Ω–µ–Ω—Ç—ã. –ü—Ä–æ–≤–µ—Ä—å—Ç–µ –∏—Ö, —É–¥–∞–ª–∏—Ç–µ –ª–∏—à–Ω–∏–µ, –ø—Ä–∏ –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ—Å—Ç–∏ –æ—Ç—Ä–µ–¥–∞–∫—Ç–∏—Ä—É–π—Ç–µ –∏ –Ω–∞–∂–º–∏—Ç–µ –∫–Ω–æ–ø–∫—É ¬´–°–æ—Ö—Ä–∞–Ω–∏—Ç—å –ø–æ—Å–ª–µ–¥–Ω–∏–µ –∏–∑–º–µ–Ω–µ–Ω–∏—è –≤ —Ñ–∞–π–ª–æ–≤—É—é —Å–∏—Å—Ç–µ–º—É¬ª.",
      "es": "Luego haz clic en ¬´Leer √∫ltimo archivo¬ª. Si el archivo es v√°lido, ver√°s los componentes. Rev√≠salos, elimina los innecesarios, edita si hace falta y haz clic en ¬´Guardar los √∫ltimos cambios en el sistema de archivos¬ª."
    }
  },
  "cm3responseparser028": {
    "key": "applyButtonLabel",
    "translations": {
      "en": "Save latest changes to filesystem",
      "ru": "–°–æ—Ö—Ä–∞–Ω–∏—Ç—å –ø–æ—Å–ª–µ–¥–Ω–∏–µ –∏–∑–º–µ–Ω–µ–Ω–∏—è –≤ —Ñ–∞–π–ª–æ–≤—É—é —Å–∏—Å—Ç–µ–º—É",
      "es": "Guardar los √∫ltimos cambios en el sistema de archivos"
    }
  },
  "cm3responseparser029": {
    "key": "applyButtonLabelApplying",
    "translations": {
      "en": "Saving changes...",
      "ru": "–°–æ—Ö—Ä–∞–Ω—è–µ–º –∏–∑–º–µ–Ω–µ–Ω–∏—è...",
      "es": "Guardando cambios..."
    }
  },
  "cm3responseparser030": {
    "key": "clearAllButtonLabel",
    "translations": {
      "en": "Clear all parsed files",
      "ru": "–û—á–∏—Å—Ç–∏—Ç—å —Å–ø–∏—Å–æ–∫ —Ñ–∞–π–ª–æ–≤",
      "es": "Borrar todos los archivos analizados"
    }
  },
  "cm3responseparser031": {
    "key": "loadLatestResponseTitle",
    "translations": {
      "en": "Load latest Perplexity Markdown",
      "ru": "–ó–∞–≥—Ä—É–∑–∏—Ç—å –ø–æ—Å–ª–µ–¥–Ω–∏–π Markdown-–æ—Ç–≤–µ—Ç Perplexity",
      "es": "Cargar el √∫ltimo Markdown de Perplexity"
    }
  }
}
```

```tsx
// @/app/[lang]/@left/(_ARTIFACT)/(_subfractals)/(_RESPONSE_PARSER)/(_client)/(_uiclientislands)/response-parser-starter-client-island.tsx [file:1]

"use client";

import { useState, useCallback } from "react";
import type { JSX } from "react";
import type { SupportedLanguage } from "@/config/translations/translations.config";
import type {
  FractalResponseParserTranslations,
  FractalResponseParserPageData,
  FractalResponseParserParsedFile,
  FractalResponseParserParseStatus,
  FractalResponseParserApplyStatus,
  FractalResponseParserApplyPhaseResult,
  FractalResponseParserLoadFileStatus,
} from "../../(_shared)/(_types)/fractal-response-parser-types";
import { readLatestResponseFileAction } from "../../(_server)/(_actions)/read-latest-response-file-action";
import { responseParserExtractAction } from "../../(_server)/(_actions)/response-parser-extract-action";
import { responseParserApplyAction } from "../../(_server)/(_actions)/response-parser-apply-action";
import { ParsedFilesPreviewPanel } from "./parsed-files-preview-panel";
import { Button } from "@/components/ui/button";
import { toast } from "sonner";

type ResponseParserStarterClientIslandProps = {
  translations: FractalResponseParserTranslations;
  lang?: SupportedLanguage;
  currentPath?: string;
  pageData?: FractalResponseParserPageData;
};

export function ResponseParserStarterClientIsland(
  props: ResponseParserStarterClientIslandProps,
): JSX.Element {
  const { translations, pageData } = props;

  // Load file phase
  const [loadFileStatus, setLoadFileStatus] =
    useState<FractalResponseParserLoadFileStatus>("idle");
  const [loadedFileInfo, setLoadedFileInfo] = useState<{
    fileName: string;
    fileSize: number;
    modifiedAt: string;
  } | null>(null);
  const [loadedContent, setLoadedContent] = useState<string>("");

  // Parse phase (Extract)
  const [parseStatus, setParseStatus] =
    useState<FractalResponseParserParseStatus>("idle");
  const [parsedFiles, setParsedFiles] = useState<
    FractalResponseParserParsedFile[]
  >([]);

  // Apply phase
  const [applyStatus, setApplyStatus] =
    useState<FractalResponseParserApplyStatus>("idle");
  const [applyResult, setApplyResult] =
    useState<FractalResponseParserApplyPhaseResult | null>(null);

  const title = pageData?.fractalName ?? translations.clientTitle;
  const description =
    pageData?.fractalDescription ?? translations.clientDescription;
  const hint = pageData?.hint ?? translations.clientHint;

  /* -------------------------------------------------------------------------- */
  /*                         Phase 0: Load File                                */
  /* -------------------------------------------------------------------------- */

  const handleLoadFile = useCallback(async () => {
    setLoadFileStatus("loading");
    setParsedFiles([]);
    setApplyResult(null);
    setLoadedContent("");
    setLoadedFileInfo(null);

    try {
      const result = await readLatestResponseFileAction();

      if (!result.success || !result.content) {
        setLoadFileStatus("error");
        toast.error(result.error || translations.loadFileStatusError);
        return;
      }

      setLoadFileStatus("success");
      setLoadedContent(result.content);
      setLoadedFileInfo({
        fileName: result.fileName || "unknown",
        fileSize: result.fileSize || 0,
        modifiedAt: result.modifiedAt || new Date().toISOString(),
      });

      toast.success(
        `${translations.loadLatestFileButtonLabel}: ${result.fileName} (${result.fileSize} bytes)`,
      );

      // Auto-parse after loading
      handleParseAfterLoad(result.content);
    } catch (error) {
      setLoadFileStatus("error");
      const message = error instanceof Error ? error.message : "Unknown error";
      toast.error(`${translations.loadFileStatusError} ${message}`);
    }
  }, [translations]);

  /* -------------------------------------------------------------------------- */
  /*                         Phase 1: Parse (Extract)                          */
  /* -------------------------------------------------------------------------- */

  const handleParseAfterLoad = useCallback(
    async (content: string) => {
      setParseStatus("parsing");
      setParsedFiles([]);
      setApplyResult(null);

      try {
        const extractResult = await responseParserExtractAction({
          markdown: content,
          mode: "code",
        });

        if (extractResult.files.length === 0) {
          setParseStatus("no-blocks");
          toast.info(
            `${translations.parseCodeStatusNoBlocks} ${extractResult.skippedBlocks} block(s) skipped.`,
          );
          return;
        }

        setParseStatus("success");
        setParsedFiles(extractResult.files);
        toast.success(
          `Extracted ${extractResult.files.length} file(s) successfully`,
        );
      } catch (error) {
        setParseStatus("error");
        const message = error instanceof Error ? error.message : "Unknown error";
        toast.error(`${translations.parseCodeStatusError} ${message}`);
      }
    },
    [translations],
  );

  /* -------------------------------------------------------------------------- */
  /*                         Phase 2: Apply (Write to FS)                      */
  /* -------------------------------------------------------------------------- */

  const handleApply = useCallback(async () => {
    if (parsedFiles.length === 0) {
      toast.error("No files to apply");
      return;
    }

    setApplyStatus("applying");
    setApplyResult(null);

    try {
      const result = await responseParserApplyAction({
        files: parsedFiles,
      });

      setApplyResult(result);

      if (result.failedCount > 0) {
        setApplyStatus("error");
        toast.error(
          `Applied ${result.successCount}, failed ${result.failedCount} file(s)`,
        );
      } else {
        setApplyStatus("success");
        toast.success(`Successfully applied ${result.successCount} file(s)`);
      }
    } catch (error) {
      setApplyStatus("error");
      const message = error instanceof Error ? error.message : "Unknown error";
      toast.error(`Apply failed: ${message}`);
    }
  }, [parsedFiles]);

  /* -------------------------------------------------------------------------- */
  /*                              Handlers                                      */
  /* -------------------------------------------------------------------------- */

  const handleFilesChange = (files: FractalResponseParserParsedFile[]) => {
    setParsedFiles(files);
  };

  const getLoadFileStatusLabel = (): string => {
    switch (loadFileStatus) {
      case "idle":
        return translations.loadFileStatusIdle;
      case "loading":
        return translations.loadFileStatusLoading;
      case "success":
        return translations.loadFileStatusSuccess;
      case "error":
        return translations.loadFileStatusError;
      default:
        return "Unknown";
    }
  };

  const getParseStatusLabel = (): string => {
    switch (parseStatus) {
      case "idle":
        return translations.parseCodeStatusIdle;
      case "parsing":
        return translations.parseCodeStatusRunning;
      case "success":
        return translations.parseCodeStatusSuccess;
      case "error":
        return translations.parseCodeStatusError;
      case "no-blocks":
        return translations.parseCodeStatusNoBlocks;
      default:
        return "Unknown";
    }
  };

  return (
    <section className="flex flex-col gap-6">
      {/* Header */}
      <div className="flex flex-col gap-2">
        <h2 className="text-lg font-semibold tracking-tight">{title}</h2>
        <p className="text-sm text-gray-700">{description}</p>
        <p className="text-xs text-gray-600">{hint}</p>
      </div>

      {/* Usage instructions instead of mode selector */}
      <div className="flex flex-col gap-1.5">
        <p className="text-xs text-gray-700">
          {translations.usageStepSetupExport}
        </p>
        <p className="text-xs text-gray-700">
          {translations.usageStepExportMarkdown}
        </p>
        <p className="text-xs text-gray-700">
          {translations.usageStepReviewAndSave}
        </p>
      </div>

      {/* Load File Section */}
      <div className="flex flex-col gap-3 rounded-lg border border-gray-200 bg-gray-50 p-4">
        <div className="flex items-center justify-between">
          <div className="flex flex-col gap-1">
            <h3 className="text-sm font-semibold">
              {translations.loadLatestResponseTitle}
            </h3>
          </div>
          <Button
            type="button"
            size="default"
            variant="default"
            onClick={handleLoadFile}
            disabled={loadFileStatus === "loading"}
          >
            {loadFileStatus === "loading"
              ? translations.loadFileStatusLoading
              : translations.loadLatestFileButtonLabel}
          </Button>
        </div>

        {/* File info */}
        {loadedFileInfo && (
          <div className="flex flex-col gap-1 rounded border border-blue-200 bg-blue-50 p-3">
            <div className="flex items-center gap-2 text-xs text-blue-900">
              <span className="font-semibold">
                üìÑ {loadedFileInfo.fileName}
              </span>
              <span>‚Ä¢</span>
              <span>{Math.round(loadedFileInfo.fileSize / 1024)} KB</span>
              <span>‚Ä¢</span>
              <span>
                {new Date(loadedFileInfo.modifiedAt).toLocaleString()}
              </span>
            </div>
            <p className="text-xs text-blue-700">
              Status: {getLoadFileStatusLabel()}
            </p>
          </div>
        )}

        {/* Parse status */}
        {loadedContent && (
          <div className="flex items-center gap-2 text-xs text-gray-600">
            <span>Parse status:</span>
            <span className="font-semibold">{getParseStatusLabel()}</span>
          </div>
        )}
      </div>

      {/* Preview Panel */}
      {parsedFiles.length > 0 && (
        <ParsedFilesPreviewPanel
          files={parsedFiles}
          onFilesChange={handleFilesChange}
          onApply={handleApply}
          isApplying={applyStatus === "applying"}
        />
      )}

      {/* Apply Results */}
      {applyResult && (
        <div className="rounded-lg border border-gray-200 bg-white p-4">
          <h3 className="mb-3 text-sm font-semibold">Apply Results</h3>
          <div className="mb-3 flex gap-4 text-xs">
            <span className="text-green-600">
              ‚úÖ Success: {applyResult.successCount}
            </span>
            <span className="text-red-600">
              ‚ùå Failed: {applyResult.failedCount}
            </span>
            <span className="text-gray-600">
              ‚è≠Ô∏è Skipped: {applyResult.skippedCount}
            </span>
          </div>
          <div className="flex flex-col gap-2">
            {applyResult.results.map((res, idx) => (
              <div
                key={idx}
                className="flex flex-col gap-1 rounded border border-gray-200 bg-gray-50 p-2"
              >
                <div className="flex items-center gap-2">
                  <span
                    className={`text-xs font-semibold ${
                      res.status === "applied"
                        ? "text-green-600"
                        : res.status === "failed"
                        ? "text-red-600"
                        : "text-yellow-600"
                    }`}
                  >
                    {res.status === "applied"
                      ? "‚úÖ"
                      : res.status === "failed"
                      ? "‚ùå"
                      : "‚è≠Ô∏è"}
                  </span>
                  <span className="text-xs font-semibold text-gray-700">
                    {res.status}
                  </span>
                </div>
                <span className="break-all font-mono text-xs text-gray-800">
                  {res.targetPath}
                </span>
                {res.message && (
                  <span className="text-xs text-gray-600">
                    {res.message}
                  </span>
                )}
              </div>
            ))}
          </div>
        </div>
      )}
    </section>
  );
}
```
