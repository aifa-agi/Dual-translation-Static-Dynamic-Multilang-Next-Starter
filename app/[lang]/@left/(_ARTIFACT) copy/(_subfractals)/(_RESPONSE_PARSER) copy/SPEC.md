app/[lang]/@left/(_ARTIFACT)/(_subfractals)/(_RESPONSE_PARSER)

specVersion: 1.0.0
stage: Mature
currentVersion: v0.2.0
fractalId: _RESPONSE_PARSER
kind: Embedded

# AIFA Fractal SPEC.md — (_RESPONSE_PARSER)

## 1. Purpose

Фрактал `(_RESPONSE_PARSER)` реализует парсинг ответов Perplexity из левого слота артефакта и управляет применением результатов к файловой системе проекта (создание/обновление файлов по AIFA‑правилам путей и структур).[file:8]  
Он служит промежуточным слоем между сырым Markdown‑ответом и конкретными изменениями в репозитории, предоставляя прозрачный, управляемый UI и типобезопасный серверный API для этих операций.[file:11]

## 2. Scope

**In scope**

- Приём сырого Markdown‑ответа от родительского фрактала `(_ARTIFACT)` (левый слот) и отображение его в UI.[file:8]  
- Парсинг Markdown в структурированные сущности:
  - CODE‑режим: извлечение всех код‑блоков с языком, содержимым и путевыми комментариями AIFA (`// app/...`).  
  - SPEC‑режим (позже): извлечение и осмысленное отображение блоков спецификаций.[file:7][file:12]  
- Формирование структурированного результата парсинга (`ParseResult`) для клиентского UI и серверных операций.  
- Планирование и выполнение файловых операций:
  - маппинг код‑блоков на целевые файлы в репозитории;  
  - создание или обновление файлов с соблюдением AIFA Core Rules (первый комментарий с полным путём, корректные директории).[file:8]  
- Базовый UI внутри embedded‑фрактала:
  - переключение режимов SPEC/CODE;  
  - отображение результата парсинга;  
  - запуск server action для применения изменений к файловой системе.[file:7]

**Out of scope (для текущей версии v0.2.0)**

- Продвинутое сравнение изменений (diff‑просмотр, merge‑конфликты).  
- Откат (rollback) изменений и хранение истории операций.  
- Полноценный интеллектуальный SPEC‑парсер с глубоким пониманием бизнес‑артефактов.  
- Автоматическое создание/редизайн fractal trees — любые изменения структуры фракталов по‑прежнему идут через архитектора и другие инструменты.[file:8][file:11]

## 3. Initial Subfractals Plan

На данном этапе `(_RESPONSE_PARSER)` остаётся монолитным embedded‑фракталом без собственных subfractals.[file:8]  

Потенциальные будущие subfractals (при росте сложности или приближении к лимитам по слоям):

- `(_RESPONSE_PARSER_RESULTS)` — выделенный embedded‑подфрактал для сложного UI результатов, diff‑просмотра и истории.  
- `(_RESPONSE_PARSER_HISTORY)` — хранение и воспроизведение прошлых применений (Improved‑этап).[file:12]

## 4. Constraints & Guidelines (Initial)

- Фрактал обязан оставаться в пределах лимитов AIFA для embedded‑фрактала:  
  - root ≤ 25 элементов, client ≤ 25, server ≤ 12, shared ≤ 12.[file:8][file:12]  
- Все реальные файловые операции оформляются как server‑сервисы и server actions текущего фрактала, а не разбросанные по другим фракталам.[file:8]  
- Любая запись файлов должна соблюдать Core Rules:
  - корректный относительный путь внутри `app`;  
  - первая строка файлов (ts/tsx/js/css/md) — однострочный комментарий с полным путём.[file:8]  
- i18n:
  - translations по‑прежнему ограничены языками en/ru/es, но список ключей расширяется под UI и статусы новой функциональности.[file:12]  

## 5. Open Questions

- Нужен ли отдельный шаг подтверждения (review) перед применением изменений к файловой системе или достаточно одного шага «Parse → Apply»?  
- Какой паттерн overwrite использовать по умолчанию:
  - полная перезапись файла из код‑блока;  
  - строгая проверка совпадения path‑комментария и существующей структуры;  
  - возможность частичного обновления (например, только тела компонентов)?  
- Нужен ли вывод подробного diff внутри этого же фрактала или он должен быть responsibility родительского `(_ARTIFACT)`?[file:11]

## 6. Global Project Context, Inherited Properties & Data Access Strategy

- Global SPEC: `config/global-SPEC.md` (наследует общие цели проекта, языки и стратегию данных).[file:10]  
- Языки приложения: полный список задаётся в глобальной конфигурации, но на уровне этого фрактала активные переводы ограничены en, ru, es с fallback по стандарту Minimal/Mature.[file:12]  
- Data Access Strategy для `(_RESPONSE_PARSER)`:
  - Источник данных для анализа: Markdown‑ответ, приходящий от родительского артефакта, а не из БД.[file:8]  
  - Серверные операции:
    - файловая система проекта через Node `fs`/`fs.promises` в server‑слое;  
    - отсутствие прямых обращений к внешним API и БД в рамках текущей задачи.[file:8]  

## 7. Fractal Instantiation Template Variables (Minimal Starter Only)

> Этот блок отражает исходную Minimal‑инстанциацию и не используется генератором на Mature‑этапе, но сохраняется для истории.[file:11]

Instantiation:
kind: Embedded
minimalTemplateId: MinimalEmbeddedFractal.v1
slot: left
fullRelativePath: app/[lang]/@left/(_ARTIFACT)/(_subfractals)/(_RESPONSE_PARSER)
fractalPath: _RESPONSE_PARSER
fractalName: ResponseParser
fractalFileItem: response-parser
parentFractalPath: _ARTIFACT


## 8. Project Languages and i18n Notes

- Глобальные языки: см. глобальный SPEC и `SupportedLanguage` в `config/translations/translations.config`.[file:10][file:12]  
- Активные локализации для этого фрактала:
  - en, ru, es — явные значения в JSON‑файле перевода;  
  - остальные языки при наличии — через fallback к en по общему i18n‑helperу.[file:12]  
- Новые ключи перевода должны добавляться строго через:
  - обновление `AllFractalResponseParserTranslationKeys` в shared‑types;  
  - добавление CUID‑записей в fractal‑translation JSON для всех трёх активных языков.[file:12]

## 9. Key User Stories & Flows

- Как разработчик, я вставляю ответ Perplexity в левый слот артефакта и переключаюсь в `CODE`‑режим, чтобы увидеть все предложенные код‑блоки с их предполагаемыми путями в репозитории.[file:7]  
- Как разработчик, я нажимаю кнопку «Parse», получаю список код‑блоков (язык, путь, первые строки) и могу решить, применять их или нет.[file:7]  
- Как разработчик, я нажимаю «Apply to filesystem» и получаю статус по каждому файлу (создан, обновлён, ошибка пути и т.п.).[file:8]  

## 10. Subfractals Map

На момент версии v0.2.0 subfractals отсутствуют, всё поведение реализовано внутри единственного embedded‑фрактала.[file:8]  
Появление subfractals будет рассматриваться при приближении к лимитам слоёв или усложнении UI/истории изменений.[file:12]

## 11. Architecture Design Decisions

- Тип фрактала: Embedded, без собственного `page.tsx`; он всегда монтируется из родительского `(_ARTIFACT)` через server entry и клиентский остров.[file:7][file:8]  
- Файловые операции выполняются только после явного действия пользователя (кнопка Apply), никаких автозаписей при парсинге.[file:11]  
- Вся логика парсинга Markdown (`extractCodeBlocks` и т.п.) живёт в shared‑слое этого фрактала и не выносится в глобальные утилиты, чтобы сохранить локальность и управляемость.[file:8]

## 12. Constraints, Non-Goals, Trade-offs

- Constraint: никаких прямых server‑вызовов, модифицирующих другие фракталы, минуя файловую систему и установленный контракт путей.[file:8]  
- Non-goal: интеллектуальное понимание домена кода (оптимизация архитектуры, рефакторинг) — только механический, но безопасный парсинг и запись.  
- Trade-off: простая модель «парсим весь Markdown → показываем список → применяем» вместо более сложной пошаговой UX‑цепочки, чтобы быстрее получить полезный Mature‑результат.[file:11]

## 13. Lessons Learned & Pitfalls

- Перемешивание SPEC/CODE‑логики в одном UI без чётких режимов приводит к путанице; для этого фрактала режимы строго разделены по состоянию `mode` и переводам.[file:7]  
- Недостаточно полагаться на язык блока (` ```

## 14. Evolution Notes and Versions

- v0.2.0 (Mature Embedded)
  - Первый полноценный бизнес‑функционал: CODE‑парсер, отображение результата и базовый push в файловую систему через server actions.[2]
  - Расширенные переводы для UI и статусов.  
- v0.1.0 (Minimal Embedded)
  - Базовый skeleton по Minimal Embedded стандарту: три слоя, i18n‑triplet, placeholder UI без реальных операций.[3][4]

## 15. AIArchitect Interaction Log

**2025-12-03T21:10:00Z** Architect  
Request: продвинуть `(_RESPONSE_PARSER)` до Mature‑этапа с реализацией CODE‑парсинга и push в файловую систему, работая по одному компоненту за итерацию.  
AI Questions: нужны ли subfractals, какие именно серверные операции допустимы, где проходит граница ответственности между этим фракталом и `(_ARTIFACT)`.  
Agreed Summary: фрактал остаётся Embedded, без subfractals; в этой итерации реализуются shared‑типы, переводы, парсер Markdown и серверные операции записи файлов, а SPEC фиксирует новый статус Mature и версию v0.2.0.[2]
